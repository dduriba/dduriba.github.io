---
title: "[Foundation Level] 제 4장. 테스트 기법"
excerpt: "Foundation Level Chapter.4 Test Techniques"
categories: istqb
tag: [ISTQB, Foundation Level]
toc: true
toc_label: "목록"
toc_icon: "bars"
toc_sticky: true
---

# 4.1 테스트 기법의 종류 (Categories of Test Techniques)
{: .notice--warning .text-center}

이번 장은 테스트 기법을 설명한다. <span style="background-color:rgb(207,228,207);">테스트 기법의 목적</span>은 <span style="background-color:rgb(237,220,195);">테스트 컨디션, 테스트 케이스, 테스트 데이터 식별을 지원하는 것</span>이다.

<span style="background-color:rgb(207,228,207);">테스트 기법의 선택은 다음과 같은 여러 요소를 기반</span>으로 이루어진다:
- <span style="background-color:rgb(237,220,195);">컴포넌트나 시스템의 복잡도</span>
- <span style="background-color:rgb(237,220,195);">규제 기준</span>
- <span style="background-color:rgb(237,220,195);">고객 또는 계약 요구사항</span>
- <span style="background-color:rgb(237,220,195);">리스크 수준과 유형</span>
- <span style="background-color:rgb(237,220,195);">사용 가능한 문서</span>
- <span style="background-color:rgb(237,220,195);">테스터의 지식과 역량</span>
- <span style="background-color:rgb(237,220,195);">사용 가능한 도구</span>
- <span style="background-color:rgb(237,220,195);">시간과 예산</span>
- <span style="background-color:rgb(237,220,195);">소프트웨어 개발 수명주기 모델</span>
- <span style="background-color:rgb(237,220,195);">컴포넌트나 시스템에서 예상되는 결함 유형</span>

일부 기법은 특정 상황과 테스트 레벨에 더 적합한 반면, 모든 테스트 레벨에 적합한 기법도 있다. 테스트 케이스를 작성할 때 테스터는 일반적으로 테스트 노력 대비 가장 좋은 결과를 얻기 위해 다양한 테스트 기법을 조합해서 사용한다.<br>
테스트 분석, 테스트 설계, 테스트 구현 활동에서 테스트 기법의 사용은 매우 비공식적인 형식(거의 또는 전혀 문서화하지 않음)부터 매우 공식적인 형식까지 다양할 수 있다. 적절한 수준의 공식성은 테스트 및 개발 프로세스의 성숙도, 시간적인 제한, 안전 또는 규정 요구사항, 관련된 사람들의 지식과 역량, 준수해야 하는 소프트웨어 개발 수명주기 모델을 포함하는 테스팅의 정황에 따라 결정된다.

## 4.1.1 테스트 기법의 종류와 특성 (Categories of Test Techniques and Their Characteristics)
{: .notice--success}

<span style="color:green">(K2) 블랙박스 테스트 기법, 화이트박스 테스트 기법, 경험 기반 테스트 기법의 특성과 공통점 및 차이점을 설명할 수 있다.</span>

이 실러버스에서는 <span style="background-color:rgb(207,228,207);">테스트 기법</span>을 블랙박스, 화이트박스, 경험 기반으로 분류한다.<br>
<span style="background-color:rgb(237,220,195);">블랙박스 테스트 기법(행위 기법 또는 행위 기반 기법이라고도 함)</span>은 <span style="background-color:rgb(242,213,214);">적절한 테스트 베이시스(예: 공식 요구사항 문서, 명세서, 유스케이스, 사용자 스토리 또는 비즈니스 프로세스)에 대한 분석을 기반으로 한다. 이 기법은 기능 테스팅과 비기능 테스팅 모두에 적용할 수 있다. 블랙박스 기법은 테스트 대상의 내부 구조를 고려하지 않고, 입력과 출력에 집중한다.</span><br>
<span style="background-color:rgb(237,220,195);">화이트박스 테스트 기법(구조 기법 또는 구조 기반 기법이라고도 함)</span>은 <span style="background-color:rgb(242,213,214);">아키텍처, 세부 설계, 내부 구조, 테스트 대상의 코드에 대한 분석을 기반으로 한다. 블랙박스 기법과는 달리, 화이트박스 기법은 테스트 대상의 내부 구조와 처리에 집중한다.</span><br>
<span style="background-color:rgb(237,220,195);">경험 기반 테스트 기법</span>은 <span style="background-color:rgb(242,213,214);">개발자, 테스터, 사용자의 경험을 활용하여 테스트를 설계, 구현, 실행한다. 이 기법은 <u>블랙박스 및 화이트박스 테스트 기법과 결합해서 사용하는 경우가 많다</u>.</span>

<span style="background-color:rgb(237,220,195);">블랙박스 테스트 기법의 일반적인 특징</span>은 다음과 같다:
- <span style="background-color:rgb(242,213,214);">테스트 컨디션, 테스트 케이스, 테스트 데이터는 소프트웨어 요구사항, 명세서, 유스케이스, 사용자 스토리와 같은 테스트 베이시스로부터 도출한다.</span>
- <span style="background-color:rgb(242,213,214);">테스트 케이스는 요구사항과 요구사항 구현 결과물 간 차이와 편차를 식별하는 데 사용한다.</span>
- <span style="background-color:rgb(242,213,214);">커버리지는 테스트 베이시스에서 테스트된 항목과 테스트 베이시스에 적용한 기법을 기반으로 측정한다.</span>

<span style="background-color:rgb(237,220,195);">화이트박스 테스트 기법의 일반적인 특성</span>은 다음과 같다:
- <span style="background-color:rgb(242,213,214);">테스트 컨디션, 테스트 케이스, 테스트 데이터는 코드, 소프트웨어 아키텍처, 상세 설계 또는 소프트웨어 구조와 관련된 기타 정보를 포함한 테스트 베이시스로부터 도출한다.</span>
- <span style="background-color:rgb(242,213,214);">커버리지는 선택한 구조(예: 코드나 인터페이스) 내에서 테스트한 항목과 테스트 베이시스에 적용된 기법을 기준으로 측정한다.</span>

<span style="background-color:rgb(237,220,195);">경험 기반 테스트 기법의 일반적인 특징</span>은 다음과 같다:
- <span style="background-color:rgb(242,213,214);">테스트 컨디션, 테스트 케이스, 테스트 데이터는 테스터, 개발자, 사용자, 기타 이해관계자의 지식과 경험과 같은 테스트 베이시스로부터 도출한다.</span>

지식과 경험은 소프트웨어의 예상 동작과 사용 환경, 발생 가능성이 있는 결함과 분포 등을 포함한다.<br>
국제 표준(ISO/IEC/IEEE 29119-4)에서 테스트 기법과 관련 커버리지 측정 방법에 대한 자세한 정보를 찾을 수 있다 (Craig 2002 와 Copeland 2004 에서 기법에 대한 추가 참조).

# 4.2 블랙박스 테스트 기법 (Black-box Test Techniques)
{: .notice--warning .text-center}

## 4.2.1 동등 분할 (Equivalence Partitioning)
{: .notice--success}

<span style="color:green">(K3) 주어진 요구사항에 동등 분할을 적용해서 테스트 케이스를 도출할 수 있다.</span>

<span style="background-color:rgb(207,228,207);">동등 분할</span>은 <span style="background-color:rgb(237,220,195);">특정 파티션(partitions)의 모든 변수는 동일한 방식으로 처리된다는 가정으로 파티션(‘동등 클래스’라고도 알려져 있음)에 데이터를 분할한다 (Kaner 2013 과 Jorgensen 2014 참조). 유효한 값과 비유효한 값 모두에 대해 동등 분할을 구성할 수 있다.</span>
- <span style="background-color:rgb(237,220,195);"><span style="color:red">유효값(valid values)이란 컴포넌트나 시스템에 입력되는 값</span>이다. 유효한 값을 포함하는 동등한 파티션을 “유효 동등 분할”이라고 한다.</span>
- <span style="background-color:rgb(237,220,195);"><span style="color:red">비유효값(invalid values)이란 컴포넌트나 시스템이 거부하는 값</span>이다. 유효하지 않은 값을 포함하는 동등한 파티션을 “비유효 동등 분할”이라고 한다.</span>
- <span style="background-color:rgb(237,220,195);">분할은 입력값, 출력값, 내부값, 시간관련값(예: 이벤트 전 또는 후), 인터페이스 매개변수(예: 통합 테스팅에서 테스트하는 통합 컴포넌트)를 포함하여 테스트 대상과 관련된 모든 데이터 요소에 대해 식별할 수 있다.</span>
- <span style="background-color:rgb(237,220,195);">필요한 경우 모든 파티션은 하위 파티션으로(sub partitions) 나눌 수 있다.</span>
- <span style="background-color:rgb(237,220,195);">모든 값은 동등 분할에 포함되어야 하며, 하나의 값은 하나의 동등 분할에만 속해야 한다.</span>
- <span style="background-color:rgb(237,220,195);">비유효 동등 분할을 테스트 케이스로 만들 때는 장애가 마스크(masked) 즉, 가려지는 것을 방지하기 위해 개별적으로 테스트해야 하며, 다른 비유효 동등 분할과 조합하지 않아야 한다. 동시에 여러 장애가 발생할 때 겉으로 드러나는 하나의 장애 때문에 나머지가 인식되지 않아 장애가 가려지는 경우가 발생한다.</span>

<span style="background-color:rgb(237,220,195);">동등 분할 기법으로 100% 커버리지를 달성하기 위해서는 식별한 모든 분할(비유효 분할 포함)의 각 분할에서 최소 한 개의 값을 사용해 테스트 케이스를 작성해야 한다. 동등 분할 커버리지는 일반적으로 백분율로 표기하며, 최소한 한 개의 값으로 테스트한 동등 분할 수를 식별한 모든 동등 분할의 수로 나눠서 계산한다. 동등 분할은 모든 테스트 레벨에 적용할 수 있다.</span>

## 4.2.2 경계값 분석 (Boundary Value Analysis)
{: .notice--success}

<span style="color:green">(K3) 주어진 요구사항에 경계값 분석을 적용해서 테스트 케이스를 도출할 수 있다.</span>

<span style="background-color:rgb(207,228,207);">경계값 분석(BVA)</span>은 <span style="background-color:rgb(237,220,195);">동등 분할의 확장 형태이지만 각 파티션이 순서화되어 있고, 숫자 또는 연속 데이터로 구성된 경우에만 적용할 수 있다. 분할의 최소값과 최대값(또는 첫 번째값과 마지막값)은 해당 분할의 경계값이 된다 (Beizer 1990 참고).<br>
예를 들어, 특정 입력 필드가 한 자리 정수값만 입력으로 받아들이고 정수가 아닌 값의 입력은 막기 위해 입력 방법을 키패드(keypad)로 제한한다고 가정해보자. 유효 범위는 1 이상 5 이하이다. 따라서 3 개의 동등 분할이 존재한다: 비유효(너무 낮음); 유효; 비유효(너무 높음). 유효 동등 분할의 경계값은 1 과 5 이다. 비유효(너무 높음) 분할의 경계값은 6 이다. 비유효(너무 낮음) 분할은 변수가 하나뿐인 파티션으로 유일한 값 0 이 경계값이 된다.<br>
위의 예제에서는 각 경계에 대해 두 개의 값을 식별했다. 비유효(너무 낮음)와 유효 사이의 경계에 대해서는 테스트 값 0, 1 을, 유효와 비유효(너무 높음) 사이의 경계에 대해서는 테스트 값 5, 6 을 선택했다. 이 기법의 여러 유형 중에는 경계당 세 개의 경계값을 식별하는 것도 있다: 경계 직전 값, 경계에 해당하는 값, 경계 직후의 값. 경계값을 세 개 선택하는 경우로 앞에 주어진 예제를 살펴보면, 낮은 쪽 경계에 해당하는 테스트 값은 0, 1, 2가 되고 높은 쪽 경계에 해당하는 테스트 값은 4, 5, 6이 된다 (Jorgensen 2014).<br>
동등 분할의 경계에서 동작이 잘못될 확률이 동등 분할 중간의 값에서 잘못될 확률에 비해 높다. 명시된 경계값과 구현한 경계값 모두 의도했던 값보다 높거나 낮게 설정되거나, 모두 생략하거나 의도하지 않았던 경계값이 추가되었을 수 있다는 사실을 기억하는 것이 중요하다. 경계값 분석과 테스팅을 통해 소프트웨어가 경계값이 원래 속한 분할의 동작이 아닌 다른 분할의 동작을 수행하는 것과 같은 종류의 결함 대부분을 식별할 수 있다.<br>
경계값 분석은 모든 테스트 레벨에 적용할 수 있다. 이 기법은 일반적으로 숫자의 범위(날짜, 시간 포함)와 연관된 요구사항을 테스트하는 데 적용된다. 경계값 분석 커버리지는 보통 백분율로 표기하며, 테스트한 경계값의 수를 식별한 모든 경계값의 수로 나눠서 계산한다.</span>

## 4.2.3 결정 테이블 테스팅 (Decision Table Testing)
{: .notice--success}

<span style="color:green">(K3) 주어진 요구사항에 결정 테이블 테스팅을 적용해서 테스트 케이스를 도출할 수 있다.</span>

<span style="background-color:rgb(207,228,207);">결정 테이블</span>은 <span style="background-color:rgb(237,220,195);">시스템이 구현해야 하는 복잡한 비즈니스 규칙을 기록하기에 좋은 방법이다. 결정 테이블을 작성할 때 테스터는 시스템의 조건(주로 입력)과 예상 동작(주로 출력)을 식별한다. 이것들은 테이블의 행(rows)을 형성하며 일반적으로 조건은 위쪽에, 기대 결과는 아래쪽에 둔다. 각 열(column)은 하나의 결정 규칙으로 특정 조건의 고유한 조합과 연관된 기대 결과로 정의한다. 조건과 기대 결과의 값은 일반적으로 참 또는 거짓으로 표기하거나, 빨간색, 녹색, 파란색 등과 같은 비연속 값으로 표기하지만 숫자나 숫자 범위로 표기하는 경우도 있다. 이러한 여러 가지 유형의 조건과 기대 결과를 하나의 결정 테이블에 표기하는 경우도 있다.</span>

결정 테이블의 <span style="background-color:rgb(237,220,195);">일반적인 표기법</span>은 다음과 같다:

<span style="background-color:rgb(242,213,214);">조건:</span>
- <span style="background-color:rgb(242,213,214);">Y, 조건이 참이라는 것을 의미 (T 또는 1로 표기할 수 있음)</span>
- <span style="background-color:rgb(242,213,214);">N, 조건이 거짓이라는 것을 의미 (F 또는 0 으로도 표기할 수 있음)</span>
- <span style="background-color:rgb(242,213,214);">—, 조건의 값이 중요하지 않다는 것을 의미 (N/A 로 표기할 수 있음)</span>

<span style="background-color:rgb(242,213,214);">기대 결과:</span>
- <span style="background-color:rgb(242,213,214);">X, 행동이 일어난다는 것을 의미 (Y, T, 1 로 표기할 수 있음)</span>
- <span style="background-color:rgb(242,213,214);">공백(blank), 행동이 일어나지 않음을 의미 (—, N, F, 0 으로 표기할 수 있음)</span>

<span style="background-color:rgb(237,220,195);">전체 결정 테이블에는 모든 조건 조합을 포괄 할 수 있는 충분한 열 (테스트 사례)이 있다. 결과에 영향을 미치지 않는열, 예를 들어, <u>불가능한 조건 조합 등을 삭제하면 테스트 케이스 수가 상당히 줄어들 수 있다</u>. 결정 테이블 축소 방법에 대한 자세한 정보는 ISTQB-CTAL-AT 에서 찾을 수 있다.<br>
결정 테이블 테스팅에서 일반적인 최소 커버리지 기준은 테이블의 결정 규칙당 최소 한 개의 테스트 케이스를 작성하는 것이다. 이것은 일반적으로 모든 조건 조합을 포함한다. 커버리지는 일반적으로 백분율로 표기하며, 최소 한 개의 테스트 케이스로 테스트한 결정 규칙의 수를 식별한 모든 결정 규칙의 수로 나눠서 계산한다.<br>
<span style="color:red">결정 테이블 테스팅의 장점은 중요한 모든 조건 조합을 식별하는 데 도움</span>이 된다는 것이다. 그 중에는 결정 테이블을 사용하지 않았으면 간과했을 수 있는 조합도 있을 수 있다. 또한, 요구사항의 누락된 부분을 찾는 데 도움이 된다. 이는 소프트웨어의 동작이 조건 조합에 영향을 받는 모든 상황에 적용 가능하며, 모든 테스트 레벨에 적용할 수 있다.</span>

## 4.2.4 상태 전이 테스팅 (State Transition Testing)
{: .notice--success}

<span style="color:green">(K3) 주어진 요구사항에 상태 전이 테스팅을 적용해서 테스트 케이스를 도출할 수 있다.</span>

<span style="background-color:rgb(237,220,195);">컴포넌트나 시스템은 현재 조건이나 기존 이력(예를 들어, 시스템이 초기화되고 난 후 발생한 이벤트)에 따라 이벤트에 대해 다르게 반응할 수 있다. 기존 이력은 <span style="color:blue">상태</span>라는 개념을 활용해서 요약할 수 있다. 상태 전이 다이어그램은 소프트웨어의 가능한 상태뿐만 아니라 소프트웨어가 상태 간에 어떻게 진입하고 빠져나오는지에 대한 전이 방법을 보여준다. <span style="color:blue">전이</span>는 <span style="color:blue">이벤트</span>에 의해 시작된다 (예를 들어, 사용자가 입력 필드에 값을 입력). 이 이벤트는 전이라는 결과를 가져온다. 하나의 이벤트에 의해 동일한 상태로부터 두 개 이상의 다른 전이가 발생할 수 있다. 상태 변화로 소프트웨어가 특정 행동을 할 수도 있다 (예: 연산 결과 또는 오류 메시지 출력).</span><br>
<span style="background-color:rgb(237,220,195);">상태 전이 테이블</span>은 <span style="background-color:rgb(242,213,214);">상태 간의 모든 유효 전이와 잠재적인 비유효 전이뿐만 아니라, 유효 전이와 관련된 이벤트, 결과 조치를 보여준다.</span> <span style="background-color:rgb(237,220,195);">상태 전이 다이어그램</span>은 <span style="background-color:rgb(242,213,214);">일반적으로 유효한 전이만 보여주며, 비유효 전이는 표시하지 않는다.</span><br>
<span style="background-color:rgb(237,220,195);">테스트는 상태의 일반적인 순서를 커버하거나, 모든 상태를 실행하거나 모든 상태 전이를 실행하거나 특정한 상태 전이 순서를 실행하거나 또는 불가능한 상태 전이를 테스트하도록 설계할 수 있다.</span><br>
<span style="background-color:rgb(207,228,207);">상태 전이 테스팅</span>은 <span style="background-color:rgb(237,220,195);">메뉴 기반 애플리케이션에 사용하며, 임베디드 소프트웨어 업계에서 널리 사용하고 있다. 이 기법은 또한 구체적인 상태를 포함한 비즈니스 시나리오를 모델링하거나 화면 탐색을 테스팅하는 데 적합하다. 상태의 개념은 추상적이다. 이는 코드 몇 줄 또는 전체 비즈니스 프로세스를 나타낼 수도 있다.<br>
커버리지는 일반적으로 백분율로 표기하며, 식별한 상태나 전이 중 테스트된 수를 식별한 모든 상태나 전이의 수로 나눠서 계산한다. 상태 전이 테스팅 커버지리 조건에 대한 추가 정보는 ISTQB-CTAL-TA 에서 찾을 수 있다.</span>

## 4.2.5 유스케이스 테스팅 (Use Case Testing)
{: .notice--success}

<span style="color:green">(K2) 유스케이스에서 테스트 케이스를 도출하는 방법을 설명할 수 있다.</span>

<span style="background-color:rgb(207,228,207);">유스케이스</span>에서 <span style="background-color:rgb(237,220,195);">테스트를 도출할 수 있으며, 이것은 소프트웨어 항목 간의 상호작용을 설계하는 특정 방법이다. 유스케이스는 소프트웨어 기능에 대한 요구사항을 통합한다. 유스케이스는 <span style="color:blue">액터(actor, 즉 사용자, 외부 하드웨어, 기타 컴포넌트나 시스템)와 대상(유스케이스를 적용하는 컴포넌트나 시스템) 간의 관계</span>이다.<br>
각 유스케이스는 대상(subject)이 하나 이상의 액터와 협력하여 수행할 수 있는 동작들을 명시하고 있다 (UML 2.5.1 2017). 유스케이스를 상호작용과 활동으로 설명하기도 하고, 적절한 경우 사전조건, 사후조건 및 자연어로 설명할 수도 있다. 액터와 대상 간의 상호작용으로 대상의 상태가 변경될 수 있다. 상호작용은 워크플로우, 활동 다이어그램, 비즈니스 프로세스 모델로 시각화할 수 있다.<br>
유스케이스에는 예외 동작 및 오류 처리(시스템 응답과 프로그래밍, 애플리케이션 및 통신 오류로부터의 복구, 예를 들어, 오류 메시지 발생)를 포함한 기본 동작의 가능한 변형이 포함된다. 테스트는 정의한 동작(기본, 예외 또는 대안, 오류 처리)을 실행하도록 설계된다. 커버리지는 일반적으로 숫자로 표기하며, 테스트한 유스케이스 동작 수를 모든 유스케이스 동작 수로 나눠서 계산한다.<br>
유스케이스의 커버리지 조건에 대한 추가 정보는 ISTQB-CTAL-TA 에서 찾을 수 있다.</span>

# 4.3 화이트박스 테스트 기법 (White-box Test Techniques)
{: .notice--warning .text-center}

<span style="background-color:rgb(207,228,207);">화이트박스 테스팅</span>은 <span style="background-color:rgb(237,220,195);">테스트 대상의 내부 <span style="color:red">구조를 기반</span>으로 한다. 화이트박스 테스트 기법은 모든 테스트 레벨에서 적용할 수 있지만, 이 절에서 언급하고 있는 두 가지 코드 관련 기법은 단위 테스트 레벨에서 가장 일반적으로 사용된다. 안전 최우선, 임무 최우선, 높은 무결성 환경에서 더 높은 커버리지 달성을 위해 적용하는 고급 기법들도 있지만, 여기서는 다루지 않는다. 그런 기법에 대한 자세한 내용에 대해서는 ISTQB-CTAL-TTA 를 참조한다.</span>

## 4.3.1 구문 테스팅과 커버리지 (Statement Testing and Coverage)
{: .notice--success}

<span style="color:green">(K2) 구문 커버리지를 설명할 수 있다.</span>

<span style="background-color:rgb(207,228,207);">구문 테스팅</span>은 <span style="background-color:rgb(237,220,195);">코드의 잠재적으로 실행 가능한 구문을 실행한다. 커버리지는 일반적으로 백분율로 표기하며, 테스트로 실행한 구문의 수를 테스트 대상의 모든 실행 가능한 구문의 수로 나눠서 계산한다.</span>

## 4.3.2 결정 테스팅과 커버리지 (Decision Testing and Coverage)
{: .notice--success}

<span style="color:green">(K2) 결정 커버리지를 설명할 수 있다.</span>

<span style="background-color:rgb(207,228,207);">결정 테스팅</span>은 <span style="background-color:rgb(237,220,195);">코드에 존재하는 결정문을 실행하고 결정문의 결과에 따라 실행되는 코드를 테스트한다. 이것을 달성하기 위해 <span style="color:red">테스트 케이스는 결정문에서 시작되는 제어 흐름을 따라 실행</span>된다 (예를 들어, <span style="color:red">IF 문</span>에서 결과가 참인 경우와 거짓인 경우; <span style="color:red">CASE 문</span>에서 <span style="color:red">기본 결과를 포함한 가능한 모든 결과를 필요로 하는 테스트 케이스</span>).<br>
커버리지는 일반적으로 백분율로 표기하며, 테스트로 실행된 결정문 결과의 수를 테스트 대상의 가능한 모든 결정문 결과의 수로 나눠서 계산한다.</span>

## 4.3.3 구문 및 결정 테스팅의 가치 (The Value of Statement and Decision Testing)
{: .notice--success}

<span style="color:green">(K2) 구문 및 결정 커버리지의 가치를 설명할 수 있다.</span>

<span style="background-color:rgb(232,233,234);">100% 구문 커버리지를 달성하면 코드에 존재하는 모든 실행 가능한 구문을 최소한 한 번씩은 테스트했다는 것을 의미하지만, 모든 결정 로직을 테스트했다는 것을 보장하지는 않는다. 이 실러버스에서 다루고 있는 두 가지 화이트박스 기법 중 구문 테스팅은 결정 테스팅보다 커버리지가 낮다.<br>
100% 결정 커버리지를 달성하면 명확한 거짓 구문이 명시되지 않은 경우(예를 들어, IF 문에 else 문이 없는 경우)에도 결과가 참인 경우와 거짓인 경우를 포함한 모든 결정 결과가 실행되었다는 것을 의미한다. <u>구문 커버리지는 다른 테스트에 의해 실행되지 않은 코드의 결함을 찾는 데 도움</u>이 된다. <u>결정 커버리지는 다른 테스트가 참과 거짓 결과 모두를 테스트하지 않은 코드의 결함을 찾는 데 도움</u>이 된다. <span style="color:red">100% 결정 커버리지는 100% 구문 커버리지를 보장하지만, 반대의 경우는 성립하지 않는다</span>.</span>

# 4.4 경험 기반 테스트 기법 (Experience-based Test Techniques)
{: .notice--warning .text-center}

<span style="background-color:rgb(207,228,207);">경험 기반 테스트 기법</span>을 적용할 경우 <span style="background-color:rgb(237,220,195);"><span style="color:blue">테스트 케이스는 테스터의 기술 역량과 직관 그리고 유사한 애플리케이션과 기술에 대한 경험을 기반으로 도출</span>한다. 이 기법은 <span style="color:blue">체계적인 다른 기법으로는 쉽게 찾아내기 어려운 테스트를 식별하는 데 도움</span>이 된다. 테스터의 접근 방식과 경험에 따라 이 기법으로 달성하는 커버리지와 효과성은 매우 다양하게 나타날 수 있다. 이 기법을 사용할 경우 커버리지를 평가하기 어려울 수 있으며 측정이 불가능할 수도 있다.<br>
이번 절에서는 일반적으로 많이 적용되는 경험 기반 기법을 설명하고 있다.</span>

## 4.4.1 오류 추정 (Error Guessing)
{: .notice--success}

<span style="color:green">(K2) 오류 추정을 설명할 수 있다.</span>

<span style="background-color:rgb(207,228,207);">오류 추정</span>은 <span style="background-color:rgb(237,220,195);">다음을 포함한 테스터의 지식을 기반으로 오류, 결함 및 장애 발생을 예측하는 데 적용하는 기술이며 다음을 포함한다:</span>
- <span style="background-color:rgb(237,220,195);">애플리케이션의 과거 동작</span>
- <span style="background-color:rgb(237,220,195);">발생하기 쉬운 오류의 유형</span>
- <span style="background-color:rgb(237,220,195);">다른 애플리케이션에서 발생한 장애</span>

<span style="background-color:rgb(237,220,195);">오류 추정 기법에 대한 <span style="color:blue">체계적인 접근법은 발생 가능한 오류, 결함, 장애 목록을 작성하고 이런 장애와 그것의 원인이 되는 결함을 노출하는 테스트를 설계</span>하는 것이다. 이러한 오류, 결함, 장애 목록은 경험, 결함 및 장애 데이터 또는 소프트웨어가 실패한 이유에 대한 일반적인 지식을 기반으로 작성할 수 있다.</span>

## 4.4.2 탐색적 테스팅 (Exploratory Testing)
{: .notice--success}

<span style="color:green">(K2) 탐색적 테스팅을 설명할 수 있다.</span>

<span style="background-color:rgb(207,228,207);">탐색적 테스팅</span>에서는 <span style="background-color:rgb(237,220,195);"><span style="color:blue">비공식(사전에 정의되지 않은) 테스트를 테스트 실행 중에 동적으로 설계, 실행, 기록하고 평가한다. 테스트 결과는 컴포넌트나 시스템에 대해 더 많이 학습하고, 더 많은 테스트가 필요한 영역에 대한 테스트를 작성하는 데 활용</span>된다.<br>
탐색적 테스팅은 <span style="color:blue">때로 세션 기반 테스팅을 사용하여 활동을 구성한다. 세션 기반 테스팅에서는 탐색적 테스팅을 정해진 시한(time-box)동안 수행하며, 테스터는 테스트 목적이 포함된 테스트 차터(test charter)를 활용해 테스팅 방향을 설정한다. 테스터는 테스트 세션 시트에 수행 단계와 발견 사항을 기록</span>한다.<br>
탐색적 테스팅은 <span style="color:blue">명세가 충분하지 않거나 적은 경우 또는 테스팅에 상당한 시간적 압박이 있을 때 가장 유용하다. 또한, 탐색적 테스팅은 다른 보다 공식적인 테스팅 기법을 보완하는 데도 유용</span>하다.<br>
탐색적 테스팅은 반응적 테스트 전략(5.2.2 절 참조)과 밀접하게 관련되어 있다. 탐색적 테스팅은 <u>다른 블랙박스, 화이트박스, 경험 기반 기법과 통합하여 사용할 수도 있다</u>.</span>

## 4.4.3 체크리스트 기반 테스팅 (Checklist-based Testing)
{: .notice--success}

<span style="color:green">(K2) 체크리스트 기반 테스팅을 설명할 수 있다.</span>

<span style="background-color:rgb(207,228,207);">체크리스트 기반 테스팅</span>에서는 <span style="background-color:rgb(237,220,195);"><span style="color:blue">체크리스트에 기록된 테스트 컨디션을 커버하기 위해 테스터가 테스트를 설계, 구현, 실행</span>한다. 테스터는 분석의 일환으로 새로운 체크리스트를 작성하거나 기존 체크리스트를 확장할 수 있지만, 기존 체크리스트를 수정하지 않고 그대로 사용하는 경우도 있다. 체크리스트는 <span style="color:blue">경험, 사용자에게 무엇이 중요한지에 대한 지식 또는 소프트웨어가 실패하는 이유와 방법에 대한 이해를 기반으로 작성할 수 있다</span>.<br>
<u>체크리스트는 기능 및 비기능 테스팅을 포함한 다양한 테스트 유형을 지원하기 위해 작성할 수 있다</u>. 구체적인 테스트 케이스가 없는 경우, 체크리스트 기반 테스팅은 대략적인 지침과 일관성을 제공할 수 있다. 이런 체크리스트는 상위 수준으로 작성되기 때문에 실제 테스팅에서 어느 정도의 가변성이 있기 마련이며, 따라서 커버리지는 늘어날 수 있지만 재현 가능성은 줄어들 수 있다.</span>

# ● 용어
{: .notice .text-center}

<details>
<summary>Keywords</summary>
<div markdown="1">

- 블랙박스 테스트 기법(black-box test technique):<br>
유의어 : 블랙박스 기법(black-box technique), 명세 기반 기법(specification-based technique), 명세 기반 테스트 기법(specification-based test technique)<br>
컴포넌트나 시스템의 내부 구조가 아닌 기능/비기능 명세를 분석해서 테스트 케이스를 도출하고 선정하는 절차

- 경계값 분석(boundary value analysis):<br>
참조 : 경계값(boundary value)<br>
경계값을 기반으로 테스트 케이스를 설계하는 블랙박스 테스트 기법

- 체크리스트 기반 테스팅(checklist-based testing): 경험, 점검, 기억에 의한 목록 또는 제품 검증 기준 및 규칙을 상위 수준으로 나열한 목록을 숙련된 테스터가 사용하는 경험 기반 테스트 기법

- 결정 커버리지(decision coverage): 결정 결과값에 대한 커버리지

- 결정 테이블 테스팅(decision table testing):<br>
참조 : Egler63<br>
연관 항목 : 결정 테이블(decision table)<br>
테스트 케이스가 결정 테이블에 표시된 입력 및 원인의 조합을 실행하도록 설계하는 블랙박스 테스트 기법

- 오류 추정(error guessing):<br>
참조 : ISO 29119<br>
<span style="color:red">과거 장애(failures)에 대한 테스터의 지식이나 장애 형태에 대한 일반적인 지식에 기초하여 테스트 케이스를 도출하는 테스트 기법</span>

- 동등 분할(equivalence partitioning):<br>
유의어 : 동등 클래스(equivalence class)<br>
명세에 기반하여 동일한 결과를 갖는 것으로 예상되는 테스트 대상 관련 데이터 요소 중 데이터값 도메인 영역의 모든 값에 대한 기대 결과가 동일하다고 추정

- 경험 기반 테스트 기법(experience-based test technique):<br>
유의어 : 경험 기반 기법(experience-based technique)<br>
테스터의 경험, 지식, 직관을 기반으로 테스트 케이스를 도출 및 선정하는 절차

- 탐색적 테스팅(exploratory testing):<br>
참조 : ISO 29119<br>
<span style="color:red">테스터가 자신의 지식, 테스트 항목에 대한 탐색, 이전 테스트 결과를 기반으로 하여 테스트를 동적으로 설계하고 실행하는 테스팅 접근법</span>

- 상태 전이 테스팅(state transition testing):<br>
연관 항목 : N-스위치 테스팅(N-switch testing)<br>
유의어 : 유한 상태 테스팅(finite state testing)<br>
상태 전이 다이어그램이나 상태 테이블을 사용해 테스트 케이스를 도출하고, 테스트 항목이 유효한 전이는 실행하고 비유효 전이는 성공적으로 차단하는지 확인하는 블랙박스 테스트 기법

- 구문 커버리지(statement coverage): 테스트 스위트(suite)가 수행한 실행문의 백분율

- 테스트 기법(test technique):<br>
유의어 : 테스트 케이스 설계 기법(test case design technique), 테스트 명세 기법(test specification technique), 테스트 기법(test technique), 테스트 설계 기법(test design technique)<br>
<span style="color:red">테스트 케이스를 도출하고 설계하는 데 사용하는 절차</span>

- 화이트박스 테스트 기법(white- box test technique):<br>
유의어 : 구조적 테스트 기법(structural test technique), 구조 기반 테스트 기법(structure-based test technique), 구조 기반 기법(structure-based technique), 화이트박스 기법(white-box technique)<br>
컴포넌트나 시스템의 내부 구조 분석에 기반하여 테스트 케이스를 선택 그리고/또는 도출하는 절차

- 세션 기반 테스팅(session-based testing): 테스트 활동을 테스트 세션으로 계획하는 테스팅 접근법. 테스트 세션 내에서는 테스트 설계와 실행이 방해받지 않고 연속해서 이루어진다. 탐색적 테스팅과 함께 사용되는 경우가 많음

</div>
</details>

# ● 샘플문제
{: .notice--danger .text-center}

A - Q19. 체크리스트 기반 테스팅(Checklist-based Testing)이란?
- a. 과거 장애에 대한 테스터의 지식이나 장애에 대한 일반적 지식에 기반해 테스트를 도출하는 테스트 기법
- b. 컴포넌트나 시스템의 명세 분석을 기반으로 하는 테스트 기법
- c. 숙련된 테스터가 제품 검증에 필수적인 일련의 규칙이나 기준 또는 참고/확인/기억해야 하는 아이템 목록을 사용하는 경험 기반 테스트 기법
- d. 테스터가 자신의 지식, 테스트 항목의 탐구, 이전 테스트 결과를 기반으로 한 테스트를 적극적으로 설계하고 실행하는 테스팅 접근법

<details>
<summary><span style="color:red">Answer</span></summary>
<div markdown="1">

FL-4.x (K1) 제 4 장 용어
- a. 오답- 에러 추정에 대한 설명이다.
- b. 오답- 블랙 박스 테스트 기법에 대한 설명이다.
- c. 정답- 다른 오답 설명 참조
- d. 오답- 탐색적 테스팅에 대한 설명이다.

</div>
</details>

---

A - Q20. 다음 중 블랙-박스 테스트 기법으로 분류할 수 있는 것은?
- a. 아키텍처 분석에 기반한 기법
- b. 상세한 설계에 따라 테스트 대상이 작동하는지를 확인하는 기법
- c. 과거 결함에 대한 지식 또는 장애에 대한 일반적인 지식을 기반으로 하는 기법
- d. 공식 요구사항에 기반한 기법

<details>
<summary><span style="color:red">Answer</span></summary>
<div markdown="1">

FL-4.1.1 (K2) 블랙박스 테스트 기법, 화이트박스 테스트 기법, 경험 기반 테스트 기법의 특성과 공통점 및 차이점을 설명할 수 있다.
- a. 오답- 화이트-박스 테스트 기법에 대한 설명이다.
- b. 오답- 화이트-박스 테스트 기법에 대한 설명이다.
- c. 오답- 경험 기반 테스트 기법에 대한 설명이다.
- d. 정답- 블랙 박스 테스트 기법(행위적 또는 행위 기반 기법이라고도 함)은 적절한 테스트 베이시스 분석을 기반으로 한다 (예: 공식 요구사항 문서, 명세서, 유스케이스, 사용자 스토리).

</div>
</details>

---

A - Q21. 다음은 결정 커버리지에 대한 설명이다.<br>
“코드에 하나의 ‘if’ 문만 있고 다른 루프나 CASE 문이 없고 테스트를 중복 실행하지 않는 경우, 하나의 테스트 케이스 수행 시 50%의 결정 커버리지를 달성할 수 있다.”<br>
다음 설명 중 옳은 것은?
- a. 위 문장은 옳다. 하나의 테스트 케이스로 100% 구문 커버리지를 달성할 수 있으므로 결정 커버리지는 50%이다.
- b. 위 문장은 옳다. 하나의 테스트 케이스는 if문의 참 또는 거짓 중 하나의 결과가 나올 것이다.
- c. 위 문장은 틀렸다. 이 경우 하나의 테스트 케이스는 결정 커버리지 25%만 보장한다.
- d. 위 문장은 틀렸다. 지나치게 광범위한 설명으로, 테스트하는 소프트웨어에 따라 참일 수도 있고 거짓일 수도 있다.

<details>
<summary><span style="color:red">Answer</span></summary>
<div markdown="1">

FL-4.3.2 (K2) 결정 커버리지를 설명할 수 있다.
- a. 오답: 위 문장이 옳다는 것은 맞지만 설명이 틀렸다. 구문과 결정 커버리지의 관계가 올바르지 않다.
- b. 정답: 문제의 정의에 따라 어떤 테스트라도 if문의 참 또는 거짓 중 하나의 결과만 나오기 때문에 50%의 결정 커버리지를 달성할 수 있다.
- c. 오답: 하나의 테스트 케이스는 25%보다 높은 결정 커버리지를 달성하게 된다. 이는 위 문장에 따라 항상 50% 결정 커버리지를 달성한다는 것을 의미한다.
- d. 오답: 각 테스트 케이스가 50% 결정 커버리지를 달성하기 때문에 위 설명은 광범위하지 않으며 항상 참이다.

</div>
</details>

---

A - Q22. 다음 중 구문 커버리지에 대한 설명 중 옳은 것은?
- a. 실행한 테스트 케이스의 백분율을 계산하고 측정하는 데 사용하는 메트릭이다.
- b. 소스코드에서 실행한 구문의 백분율을 계산하고 측정하는 데 사용하는 메트릭이다.
- c. 성공한 테스트 케이스로 수행한 구문의 수를 계산하고 측정하는 데 사용하는 메트릭이다.
- d. 모든 구문이 커버되었는지 참/거짓으로 판별하는 메트릭이다.

<details>
<summary><span style="color:red">Answer</span></summary>
<div markdown="1">

FL-4.3.1 (K2) 구문 커버리지를 설명할 수 있다.
- a. 오답: 구문 커버리지는 테스트 케이스로 수행한 구문의 백분율을 측정한다.
- b. 정답: 구문 테스팅은 코드에서 실행 가능한 구문을 수행한다. 구문 커버리지는 테스트로 수행한 구문 수를 테스트 대상의 실행 가능한 전체 구문수로 나누어 측정하며 일반적으로 백분율로 표현한다.
- c. 오답: 커버리지는 성공/실패를 측정하지 않는다.
- d. 오답: 구문 커버리지는 메트릭일 뿐 참/거짓 구문을 제공하지 않는다.

</div>
</details>

---

A - Q23. 구문 커버리지와 결정 커버리지의 관계에 대한 설명 중 옳은 것은?
- a. 100% 결정 커버리지는 100% 구문 커버리지를 보장한다.
- b. 100% 구문 커버리지는 100% 결정 커버리지를 보장한다.
- c. 50% 결정 커버리지는 50% 구문 커버리지를 보장한다.
- d. 100% 결정 커버리지는 불가능하다.

<details>
<summary><span style="color:red">Answer</span></summary>
<div markdown="1">

FL-4.3.3 (K2) 구문 및 결정 커버리지의 가치를 설명할 수 있다.
- a. 정답: 옳은 설명이다. 100%의 결정 커버리지를 달성하면 구문 커버리지도 100%가 된다.
- b. 오답: 100% 구문 커버리지를 달성해도 결정 커버리지가 100%라는 것을 의미하지 않기 때문에 틀린 설명이다.
- c. 오답: 우리는 100% 값에 대한 설명만 할 수 있기 때문에 틀린 설명이다.
- d. 오답: 틀린 설명이다.

</div>
</details>

---

A - Q24. 다음 중 탐색적 테스팅이 적합한 상황은?
- a. 시간 압박 때문에 정의된 테스트의 실행을 빠르게 진행해야 할 때
- b. 시스템이 점진적으로 개발되고 테스트 차터가 없을 때
- c. 유사한 어플리케이션과 기술에 대한 충분한 지식을 가진 테스터가 있을 때
- d. 시스템에 대한 충분한 지식이 이미 있고 테스트가 충분히 수행되었다는 근거를 제공해야 할 때

<details>
<summary><span style="color:red">Answer</span></summary>
<div markdown="1">

FL-4.4.2 (K2) 탐색적 테스팅을 설명할 수 있다.
- a. 오답: 탐색적 테스팅은 이미 정의된 테스트의 속도를 높이는 데 적합하지 않다. 특정 요구 사항이 거의 없거나 부적절하거나 테스트에 상당한 시간적 압박이 있을 때 가장 유용하다.
- b. 오답: 테스트 분석을 통해 작성된 테스트 차터가 없다는 것은 탐색적 테스팅 실행에 대한 부적절한 전제 조건이다.
- c. 정답: 탐색적 테스트는 유사한 애플리케이션에 대한 지식과 기술을 가진 숙련된 테스터가 수행해야 한다.
- d. 오답: 탐색적 테스팅만으로는 테스트가 충분히 수행됐다는 근거를 제공하기에 적합하지 않으며 다른 테스트 방법과 함께 고려돼야 한다.

</div>
</details>

---

A - Q25. 직원의 보너스를 계산하는 소프트웨어가 있다. 보너스는 음수(negative)는 될 수 없지만 0 은 될 수 있다. 보너스는 근무 기간에 따라 산정한다.
- 2 년 이하
- 2 년 초과 5 년 미만
- 5 년 이상 10 년 이하 또는 10 년 초과

보너스를 계산하기 위해 모든 유효 동등 파티션(valid equivalence partitions)을 커버하는 최소 테스트 케이스 수는 몇 개인가?
- a. 3
- b. 5
- c. 2
- d. 4

<details>
<summary><span style="color:red">Answer</span></summary>
<div markdown="1">

FL-4.2.1 (K3) 주어진 요구사항에 동등 분할을 적용해서 테스트 케이스를 도출할 수 있다.
- a. 오답: 너무 적음(정답에서 4 개의 유효한 파티션 참조)
- b. 오답: 너무 많음(정답에서 4 개의 유효한 파티션 참조)
- c. 오답: 2 개는 너무 적음(정답에서 4 개의 유효한 파티션 참조)
- d. 정답: 4 개의 동등 파티션이 질문의 설명과 일치한다.<br>
즉, 각 동등 파티션에 대해 하나 이상의 테스트 케이스가 작성되어야 한다.
1. 동등 파티션: 0≤ 근무 연한 ≤ 2
2. 동등 파티션: 2 < 근무 연한 <5
3. 동등 파티션: 5 ≤ 근무 연한 ≤ 10
4. 동등 파티션: 10 < 근무 연한

</div>
</details>

---

A - Q26. 속도 제어 및 알림 시스템이 다음과 같이 동작한다:
- 50 km/h 이하로 주행 시 아무 일도 일어나지 않음
- 50 km/h 보다는 빠르지만, 55 km/h 이하인 경우 경고 메시지 표시
- 55 km/h 보다는 빠르지만, 60 km/h 이하로 주행 시 벌금 부과
- 60 km/h 보다 빠르게 주행 시 운전 면허 중지<br>
속도 단위 Km/h 는 시스템에서 정수만 가능

동등 클래스(equivalence classes) 경계에 있는 값만을 선택하는 경계 값 분석을 적용해 식별할 수 있는 값 세트(km/h)로 가장 적절한 것은?
- a. 0, 49, 50, 54, 59, 60
- b. 50, 55, 60
- c. 49, 50, 54, 55, 60, 62
- d. 50, 51, 55, 56, 60, 61

<details>
<summary><span style="color:red">Answer</span></summary>
<div markdown="1">

FL-4.2.2 (K3) 주어진 요구사항에 경계값 분석을 적용해서 테스트 케이스를 도출할 수 있다.<br>
다음과 같이 동등 분할을 수행하여 경계값을 도출할 수 있다:
1. 50 이하, 경계값 50
2. 51 ~ 55, 경계값 51, 55
3. 56 ~ 60, 경계값 56, 60
4. 60 이상, 경계값 61

용어집 V3.2 에 따른 경계값: 식별된 동등 분할의 최소값 또는 최대값<br>
따라서,
- a. 오답: 모든 경계값을 포함하지 않으며, 동등 파티션의 경계값이 아닌 0, 49, 59 가 포함되어 있다.
- b. 오답: 모든 경계값을 포함하지 않았다. 51 과 55 가 누락되었다.
- c. 오답: 모든 경계값을 포함하지 않으며, 동등 파티션의 경계값이 아닌 49, 62, 54 가 포함되어 있다.
- d. 정답: 모든 경계값을 포함하고 있다.

</div>
</details>

---

A - Q27. 1 년 이상 근무한 직원들에게 합의한 개별 성과 목표를 달성하면 보너스를 지급하는 회사가 있다.<br>
이러한 사실을 결정 테이블로 표현할 수 있다.

<img src="/img/istqbCtfl/QnA_A27.png"/>

다음 테스트 케이스 중 실제로 발생할 수 있는 경우지만, 위 결정 테이블에서 누락된 것은?
- a. 조건1 = YES, 조건2 = NO, 조건3 = YES, 예상결과 = NO
- b. 조건1 = YES, 조건2 = YES, 조건3 = NO, 예상결과 = YES
- c. 조건1 = NO, 조건2 = NO, 조건3 = YES, 예상결과 = NO
- d. 조건1 = NO, 조건2 = YES, 조건3 = NO, 예상결과 = NO

<details>
<summary><span style="color:red">Answer</span></summary>
<div markdown="1">

FL-4.2.3 (K3) 주어진 요구사항에 결정 테이블 테스팅을 적용해서 테스트 케이스를 도출할 수 있다.
- a. 오답: 목표에 대한 합의가 없으면 목표를 달성할 수 없다. 이러한 상황이 발생할 수 없기 때문에 현실에서 가능한 시나리오가 아니다.
- b. 오답: 합의된 목표에 도달하지 않아 보너스가 지급되지 않기 때문에 테스트 케이스가 객관적으로 잘못되었다.
- c. 오답: <span style="color:red">목표에 대한 합의가 없으므로 목표에 도달할 수 없다.</span> 이러한 상황이 발생할 수 없기 때문에 현실에서 가능한 시나리오가 아니다.
- d. 정답: 테스트 케이스는 너무 짧은 근무 기간과 합의된 목표를 달성하지 못하여 보너스가 지급되지 않는 상황을 설명한다. 이 상황을 실제로 발생할 수 있지만 결정 테이블에는 없다.

</div>
</details>

---

A - Q28. 아래에 주어진 상태 전이 다이어그램과 테스트 케이스에 대한 설명 중 옳은 것은?

<img src="/img/istqbCtfl/QnA_A28.png"/>

- a. 위 테스트 케이스는 상태 전이 다이어그램의 유효 및 비유효 전이를 모두 커버하는데 사용할 수 있다.
- b. 위 테스트 케이스는 상태 전이 다이어그램의 모든 가능한 유효 전이를 표현하고 있다.
- c. 위 테스트 케이스는 상태 전이 다이어그램의 유효 전이 중 몇 가지만 표현하고 있다.
- d. 위 테스트 케이스는 상태 전이 다이어그램에서 한 쌍의 전이를 표현하고 있다.

<details>
<summary><span style="color:red">Answer</span></summary>
<div markdown="1">

FL-4.2.4 (K3) 주어진 요구사항에 상태 전이 테스팅을 적용해서 테스트 케이스를 도출할 수 있다.<br>
제안된 테스트 케이스는 주어진 상태 전이 다이어그램에서 5 가지의 모든 유효 전이를 포함하고 있다. (S1 ->S2, S2 -> S1, S2 -> S3, S3 -> S2, S3 -> S1)<br>
따라서,
- a. 오답: 비유효 전이는 커버되지 않았다.
- b. 정답: 모든 유효 전이를 커버하고 있다.
- c. 오답: 모든 유효 전이를 커버하고 있다.
- d. 오답: 테스트 케이스가 한 쌍의 전이(pairs of transition)로 설계되지 않았다.

</div>
</details>

---

A - Q29. 다음은 비디오 애플리케이션의 요구사항이다: 이 애플리케이션은 다음과 같은 해상도에 따라 비디오를 재생한다.
1. 640x480
2. 1280x720
3. 1600x1200
4. 1920x1080

다음 중 이 요구사항을 테스트하기 위해 동등분할 테스트 기법을 적용해 도출한 테스트 케이스 목록은 무엇인가?
- a. 애플리케이션이 1920x1080 의 화면 사이즈로 비디오를 재생할 수 있는지 확인한다 (테스트 케이스 1 개).
- b. 애플리케이션이 640x480 과 1920x1080 의 화면 사이즈로 비디오를 재생할 수 있는지 확인한다 (테스트 케이스 2 개).
- c. 애플리케이션이 요구사항에 있는 각각의 화면 사이즈로 비디오를 재생할 수 있는지 확인한다 (테스트 케이스 4 개).
- d. 애플리케이션이 요구사항에 있는 화면 사이즈 중 하나로 비디오를 재생할 수 있는지 확인한다 (테스트 케이스 1 개).

<details>
<summary><span style="color:red">Answer</span></summary>
<div markdown="1">

FL-4.2.1 (K3) 주어진 요구사항에 동등 분할을 적용해서 테스트 케이스를 도출할 수 있다.
- a. 오답: 정답 c.의 해설 참조
- b. 오답: 정답 c.의 해설 참조
- c. 정답: 이 요구사항은 개별적인 값들이 열거되어 있는 경우이다. 각각의 값이 그 자체로 동등 분할이 되기 때문에 동등 분할 테스트 기법을 사용하는 경우 각각의 값을 테스트해야 한다.
- d. 오답: 정답 c.의 해설 참조

</div>
</details>

---

B - Q19. 다음 중 탐색적 테스팅을 가장 잘 설명한 것은?
- A. 테스트 대상의 배경에 대한 심층적인 조사를 통해 테스트 케이스로 확인된 잠재적인 약점을 식별하는 테스트 방법
- B. 테스터가 그들의 지식, 테스트 항목에 대한 탐색 및 이전 테스트 결과를 기반으로 테스트를 동적으로 설계하고 실행하는 테스팅 접근 방식
- C. 테스트 활동이 테스트 분석 및 설계의 중단되지 않는 세션으로 계획되는 테스트 설계 접근법으로, 체크리스트 기반 테스팅과 함께 사용되는 경우가 많음
- D. 테스터의 경험과 지식, 직관에 기반한 테스팅

<details>
<summary><span style="color:red">Answer</span></summary>
<div markdown="1">

용어 (K1)
- A. 오답- 탐색적 테스팅은 일정이 짧을 때 수행하는 경우가 많으므로 테스트 대상의 배경에 대한 심층적인 조사를 수행하기에는 쉽지 않다.
- B. 정답- 용어사전 참조
- C. 오답- 용어사전에서 세션 기반 테스팅을 설명하고 있다. 단 테스트 실행을 테스트 분석이라고 한 부분이 다르다.
- D. 오답- <span style="color:red">용어사전에 따르면, 경험 기반 테스팅의 정의이다.</span>

</div>
</details>

---

B - Q20. 다음 중 테스트 기법과 그 설명을 올바르게 연결한 것은?
1. 테스트 대상의 선택된 구조에 기반하여 커버리지 측정
2. 테스트 대상 내부의 절차 확인
3. 일어날 가능성이 있는 결함과 그 분포를 기반으로 테스트
4. 요구사항과의 차이를 확인
5. 사용자 스토리를 테스트 베이시스로 사용

다음 네 가지 옵션에 대한 표기법 사용:<br>
블랙박스 - 블랙박스 테스트 기법<br>
화이트박스 - 화이트박스 테스트 기법<br>
경험 - 경험 기반 테스트 기법<br>

- A. 블랙박스–4,5 화이트박스–1,2 경험–3
- B. 블랙박스–3 화이트박스–1,2 경험–4,5
- C. 블랙박스–4 화이트박스–1,2 경험–3,5
- D. 블랙박스–1,3,5 화이트박스–2 경험–4  

<details>
<summary><span style="color:red">Answer</span></summary>
<div markdown="1">

FL-4.1.1 (K2) 블랙박스 테스트 기법, 화이트박스 테스트 기법, 경험 기반 테스트 기법의 특성과 공통점 및 차이점을 설명할 수 있다.

실러버스 4.1.1에 따라 다음과 같이 테스트 기법과 설명을 묶을 수 있다:

블랙박스 테스트 기법<br>
요구사항과의 차이를 확인 (4)<br>
사용자 스토리를 테스트 베이시스로 사용 (5)

화이트박스 테스트 기법<br>
테스트 대상의 선택 구조에 기초해 커버리지 측정 (1)<br>
테스트 대상 내부의 진행절차 확인 (2)

경험기반 기법<br>
일어날 가능성이 있는 결함과 그 분포를 기반으로 테스트 (3)

따라서 A 가 정답이다

</div>
</details>

---

B - Q21. 사용자의 건강 유지를 위해 매일의 걸음 수를 측정해 피드백을 제공하는 피트니스 앱이 있다.<br>
걸음 수에 따른 피드백 메시지는 다음과 같다:
- 1000 이하 - 카우치 포테이토 (Couch Potato)!
- 1000 초과 ~ 2000 이하 - 게으름뱅이 (Lazy Bones)!
- 2000 초과 ~ 4000 이하 - 거의 도달 (Getting There)!
- 4000 초과 ~ 6000 이하 - 괜찮아요 (Not Bad)!
- 6000 초과 - 잘하고 있어요 (Way to Go)!

다음 중 동등 분할 커버리지가 가장 높은 테스트 입력값의 묶음은?
- A. 0, 1000, 2000, 3000, 4000
- B. 1000, 2001, 4000, 4001, 6000
- C. 123, 2345, 3456, 4567, 5678
- D. 666, 999, 2222, 5555, 6666

<details>
<summary><span style="color:red">Answer</span></summary>
<div markdown="1">

FL-4.2.1 (K3) 주어진 요구사항에 동등 분할을 적용해서 테스트 케이스를 도출할 수 있다.<br>
동등 분할을 통해 다음과 같이 유효한 동등 파티션으로 나눌 수 있다:
- (1) 1000 이하 - 카우치 포테이토(Couch Potato)!
- (2) 1000 초과 ~ 2000 이하 - 게으름뱅이(Lazy Bones)!
- (3) 2000 초과 ~ 4000 이하 - 거의 도달(Getting There)!
- (4) 4000 초과 ~ 6000 이하 - 괜찮아요(Not Bad)!
- (5) 6000 초과 - 잘하고 있어요(Way to Go)!

따라서 각각의 입력값이 커버하는 파티션은 다음과 같다
- A. 0 (1), 1000 (1), 2000 (2), 3000 (3), 4000 (3) – 5개 중 3개 
- B. 1000 (1), 2001 (3), 4000 (3), 4001 (4), 6000 (4) – 5개 중 3개
- C. 123 (1), 2345 (3), 3456 (3), 4567 (4), 5678 (4) – 5개 중 3개
- D. 666 (1), 999 (1), 2222 (3), 5555 (4), 6666 (5) – 5개 중 4개

따라서 D 가 정답이다

</div>
</details>

---

B - Q22. 식물용 일별 일조량 기록기(daily radiation recorder for plants)는 식물이 태양에 노출된 시간(3시간 미만, 3시간 이상 6시간 미만, 6시간 이상)과 햇빛의 평균 강도(아주 낮음, 낮음, 중간, 높음)를 조합하여 일조량 점수를 산정한다.<br>
다음과 같은 테스트 케이스가 있다:

<img src="/img/istqbCtfl/QnA_B22.png"/>

유효한 동등 분할 입력값을 모두 커버하기 위해 추가해야 하는 최소의 테스트 케이스는 몇 개인가?
- A. 1
- B. 2
- C. 3
- D. 4

<details>
<summary><span style="color:red">Answer</span></summary>
<div markdown="1">

FL-4.2.1 (K3) 주어진 요구사항에 동등 분할을 적용해서 테스트 케이스를 도출할 수 있다.<br>
다음과 같이 유효한 입력값의 동등 파티션을 구할 수 있다:

노출시간
- (1) 3시간미만
- (2) 3시간 이상 6시간 미만
- (3) 6시간이상

햇빛 강도
- (4) 아주 낮음
- (5) 낮음
- (6) 중간
- (7) 높음

문제에서 주어진 테스트 케이스는 다음과 같은 입력에 대한 동등 파티션을 커버한다.
- T1 1.5 (1) 아주 낮음 (4)
- T2 7.0 (3) 중간 (6)
- T3 0.5 (1) 아주 낮음 (4)
 
따라서, 아직 커버되지 않은 입력 동등 파티션은 (2), (5), (7)이다. (2)의 경우 (5)나 (7)을 테스트하면서 같이 테스트할 수 있으므로 2개의 테스트 케이스만 더 있으면 된다.<br>
따라서 정답은 B이다

</div>
</details>

---

B - Q23. 스마트 홈 앱은 이전 주의 집안 평균 기온을 측정하고 이를 기반으로 환경 친화적인 관점에서 거주자에게 피드백을 제공한다.<br>
다양한 기온 범위에 대한 피드백은 다음과 같다:
- ~10°C - 매우 추움
- 11°C ~ 15°C - 서늘함
- 16°C ~ 19°C - 쾌적함
- 20°C ~ 22°C - 따뜻함
- 23°C ~ - 너무 더움
 
최소값과 최대값만 사용하는 경계값 분석(BVA only Min-Max values)을 적용할 때, 다음 테스트 입력값 집합에서 경계값 분석 커버리지가 가장 높은 것은 무엇인가?
- A. 0°C, 11°C, 20°C, 22°C, 23°C
- B. 9°C, 15°C, 19°C, 23°C, 100°C
- C. 10°C, 16°C, 19°C, 22°C, 23°C
- D. 14°C, 15°C, 18°C, 19°C, 21°C, 22°C

<details>
<summary><span style="color:red">Answer</span></summary>
<div markdown="1">

FL-4.2.2 (K3) 주어진 요구사항에 경계값 분석을 적용해서 테스트 케이스를 도출할 수 있다.<br>
주어진 입력 동등 파티션에 대해 위에서 사용한 경계값 기법은 다음 8 개의 커버리지 항목을 생성한다:<br>
10° C, 11° C, 15° C, 16° C, 19° C, 20° C, 22° C, 23° C.<br>
각 옵션 문항이 경계값 중 몇 개를 포함했는지 살펴보면:
- A. 8개 중 4개 (11, 20, 22, 23)
- B. 8개 중 3개 (15, 19, 23)
- C. 8개 중 5개 (10, 16, 19, 22, 23)
- D. 8개 중 3개 (15, 19, 22)

따라서, 정답은 C 이다

</div>
</details>

---

B - Q24. 속도위반 벌금 시스템에 대한 결정 테이블 테스팅을 수행하고 있다. 규칙 1, 4를 테스트하는 2 개의 테스트 케이스를 아래와 같이 작성했다:

<img src="/img/istqbCtfl/QnA_B24_1.png"/>

추가 테스트 케이스가 아래와 같다면:

<img src="/img/istqbCtfl/QnA_B24_2.png"/>

규칙 1, 4 에 대해 이미 작성한 테스트 케이스와 합쳐 100% 결정 테이블 테스팅 커버리지를 달성하는 추가 테스트 케이스 2 개는 무엇인가?
- A. DT1, DT2
- B. DT2, DT3
- C. DT2, DT4
- D. DT3, DT4

<details>
<summary><span style="color:red">Answer</span></summary>
<div markdown="1">

FL-4.2.3 (K3) 주어진 요구사항에 결정 테이블 테스팅을 적용해서 테스트 케이스를 도출할 수 있다.<br>
결정 테이블 테스팅의 모든 경우의 수는 아래와 같다:

<img src="/img/istqbCtfl/QnA_B24_3.png"/>

100% 커버리지를 달성하기 위해 규칙 2, 3을 확인하는 테스트 케이스가 필요하다. DT4는 규칙 2의 벌금 조건을 만족하고 DT2는 규칙 3의 벌금 조건을 만족한다.

따라서 정답은 C 이다.

</div>
</details>

---

B - Q25. 다음은 배터리 충전 소프트웨어의 상태 전이 모델이다:

<img src="/img/istqbCtfl/QnA_B25_1.png"/>

다음 중 이 상태 모델의 가장 높은 전이 커버리지를 제공하는 전이 순서는?
- A. 방전→대기→방전→대기→미세전류 충전→충전→높음→충전→낮음
- B. 대기→미세전류 충전→대기→방전→대기→미세전류 충전→충전→낮음→충전
- C. 높음→충전→낮음→충전→미세전류 충전→대기→미세전류 충전→대기→미세전류 충전→충전
- D. 대기→미세전류 충전→충전→높음→충전→미세전류 충전→대기→방전→대기

<details>
<summary><span style="color:red">Answer</span></summary>
<div markdown="1">

FL-4.2.4 (K3) 주어진 요구사항에 상태 전이 테스팅을 적용해서 테스트 케이스를 도출할 수 있다.

<img src="/img/istqbCtfl/QnA_B25_2.png"/>

각 옵션 문항의 전이 커버리지는 다음과 같다:
- A. 방전(2)대기(1)방전(2)대기(3)미세전류 충전(5)충전(9)높음(10)충전(7)낮음 = 10 개 전이 중 7 개
- B. 대기(3)미세전류 충전(4)대기(1)방전(2)대기(3)미세전류 충전(5)충전(7)낮음(8)충전 = 10 개 전이 중 7 개
- C. 높음(10)충전(7)낮음(8)충전(6)미세전류 충전(4)대기(3)미세전류 충전(4)대기(3)미세전류 충전 (5) 충전 = 10 개 전이 중 7 개
- D. 대기(3)미세전류 충전(5)충전(9)높음(10)충전(6)미세전류 충전(4)대기(1)방전(2)대기 = 10 개 전이 중 8 개

따라서 정답은 D 이다.

</div>
</details>

---

B - Q26. 다음 중 유스케이스에서 테스트 케이스를 도출하는 방법을 가장 잘 설명한 것은?
- A. 테스트 케이스는 관련자들(actors)과 협력해 테스트 중인 시스템이 수행하는 명시된 기본, 예외 및 에러 동작의 실행을 위해 생성한다.
- B. 테스트 케이스는 유스케이스에 들어 있는 컴포넌트를 식별하고 이런 컴포넌트들의 상호작용을 수행하는 통합 테스트를 생성함으로써 도출한다.
- C. 테스트 케이스는 사용자 인터페이스가 사용하기 쉽게 하기 위해 시스템과 관련자들(actors) 간의 상호작용을 분석하여 생성한다.
- D. 테스트 케이스는 유스케이스의 비즈니스 프로세스 흐름에서 각각의 결정 포인트를 수행하고 이런 흐름의 100% 결정 커버리지를 달성하기 위해 도출한다.

<details>
<summary><span style="color:red">Answer</span></summary>
<div markdown="1">

FL-4.2.5 (K2) 유스케이스에서 테스트 케이스를 도출하는 방법을 설명할 수 있다.
- A. 정답- 실러버스 4.2.5 에 따르면, 각각의 유스케이스는 하나의 주체가 하나 이상의 사용자와 상호작용할 수 있는 행동을 설명한다. 또한 각각의 행위(기본, 예외 및 에러 동작)를 확인하기 위해 테스트를 설계한다는 설명도 덧붙여져 있다.
- B. 오답- 유스케이스는 일반적으로 요구사항을 지칭한다. 따라서 이 요구사항을 구현할 컴포넌트는 포함하지는 않는다.
- C. 오답- 유스케이스를 기반으로 한 테스트는 사용자와 시스템 간의 상호작용을 수행하지만, 기능에 초점을 맞추고 있으며 사용자 인터페이스의 사용성은 고려하지 않는다.
- D. 오답- 유스케이스를 통해 유스케이스 경로를 커버하는 테스트이지만, 유스케이스에는 이런 경로의 결정 커버리지에 대한 개념은 없고 비즈니스 프로세스 흐름에 대한 것도 아니다.

</div>
</details>

---

B - Q27. 다음 구문 커버리지에 대한 설명 중 맞는 것은?
- A. 구문 커버리지는 테스트로 수행한 소스 코드의 라인 수(주석 제외)를 측정한 것이다.
- B. 구문 커버리지는 테스트로 수행한 소스 코드에서 실행 가능한 구문의 비율을 측정한 것이다.
- C. 구문 커버리지는 테스트로 수행한 소스 코드 라인(코멘트 없는)의 비율을 측정한 것이다.
- D. 구문 커버리지는 테스트로 수행한 소스코드에서 실행 가능한 구문 수를 측정한 것이다.

<details>
<summary><span style="color:red">Answer</span></summary>
<div markdown="1">

FL-4.3.1 (K2) 구문 커버리지를 설명할 수 있다.
- A. 오답- 구문 커버리지는 테스트로 수행한 실행 가능한 구문의 비율을 측정한 것이다. 실행 가능한 구문 수는 주석을 뺀 코드 수에 가깝지만, 이 옵션은 코드 라인 수에 대해서만 언급하고 있으며 수행된 비율은 언급하지 않고 있다.
- B. 정답- 실러버스(4.3.1)에 따르면, 구문 커버리지는 테스트로 수행한 구문 중에서 실행 가능한 비율을 측정한 것이다(일반적으로 백분율로 나타낸다).
- C. 오답- 구문 커버리지는 테스트로 수행한 구문 중에서 실행 가능한 비율을 측정한 것이지만, 실행 불가능한 구문도 있다(예: 주석).
- D. 오답- 구문 커버리지는 테스트로 수행한 구문 중에서 실행 가능한 비율을 측정한 것이다. 이 옵션은 실행된 구문의 수에 대해서만 말하고 비율에 대해서는 언급하고 있지 않다.

</div>
</details>

---

B - Q28. 다음 중 결정 커버리지에 대한 설명으로 맞는 것은?
- A. 결정 커버리지는 소스코드 내 가능한 경로 중 테스트로 실행한 비율을 측정한 것이다.
- B. 결정 커버리지는 컴포넌트 내 비즈니스 흐름 중 테스트로 실행한 비율을 측정한 것이다.
- C. 결정 커버리지는 코드 내 ‘if’문 중 참과 거짓 결과를 모두 실행한 비율을 측정한 것이다.
- D. 결정 커버리지는 소스코드 내 결정문 결과 중 테스트로 실행한 비율을 측정한 것이다.

<details>
<summary><span style="color:red">Answer</span></summary>
<div markdown="1">

FL-4.3.2 (K2) 결정 커버리지를 설명할 수 있다.
- A. 오답- 소스코드 내 경로란 코드의 시작 점에서 끝나는 점까지 갈 수 있는 다양한 방법 중 특정 하나를 얘기하며, 해당 경로를 따라가다 보면 여러 개의 결정문과 결정문의 결과값이 실행될 수 있다. 서로 다른 2개의 경로가 따라가는 결정문 결과값 하나를 제외하고 완전히 동일할 수 있다. 즉, 경로가 따라가는 결과값 중 하나만 다르게 해도 완전히 새로운 경로가 탄생하게 된다. 일반적으로 경로 커버리지를 달성하는 테스트 케이스 중 극히 일부만 가지고도 결정 커버리지를 달성할 수 있다. 실제로는 지극히 단순한 몇 프로그램을 제외한 모든 프로그램('while' 루프 등의 무제한 루프를 가진 모든 프로그램 포함)은 잠재적으로 무한한 경로를 가지므로 커버리지를 측정하는 것은 사실상 불가능하다.
- B. 오답- 비즈니스 흐름 커버리지를 달성하는 것은 유스케이스 테스팅의 주된 목표가 될 수 있지만, 유스케이스가 하나의 컴포넌트만 다루는 경우는 매우 드물다. 특정 비즈니스 흐름에 포함된 결정문을 커버하는 것이 가능할 수도 있지만, 그러기 위해서는 세부사항이 충분히 명시돼 있어야 한다. 비즈니스 흐름이 일부 결정을 커버하더라도 "결정 커버리지" 측정값은 비즈니스 흐름의 백분율이 아니라 비즈니스 흐름으로 인해 실행된 결정 결과의 백분율을 측정한다.
- C. 오답- 100%의 결정 커버리지를 달성하려면 모든 ‘if’ 문의 참과 거짓이 모두 실행되어야 하지만, 일반적으로 코드에는 결정 커버리지를 측정할 때 고려해야 할 다른 결정사항들이 존재한다(예: ‘case’문, 코드 제어 루프).
- D. 정답- 실러버스 4.3.2 에 나와 있듯이, 결정 커버리지는 결정문 결과 중 실행된 비율을 측정한 것이다(일반적으로 백분율로 표현한다).

</div>
</details>

---

B - Q29. 다음 중 오류 추정의 기본 개념을 가장 잘 설명한 것은?
- A. 오류 추정을 위해서는 테스터가 테스트 대상의 사용자라고 가정하고 사용자가 테스트 대상과 상호작용하면서 할 수 있는 실수를 추정하는 것이다.
- B. 오류 추정은 테스터의 개발 경험과 개발할 때 했던 실수를 활용하는 것이다.
- C. 오류 추정은 테스터의 지식과 과거에 발견했던 결함에 대한 경험, 개발자들이 흔히 범하는 실수를 활용하는 것이다.
- D. 오류 추정은 개발자들이 할 수 있는 실수를 식별하기 위해 테스터가 개발 작업을 빠르게 따라하는 것이다.

<details>
<summary><span style="color:red">Answer</span></summary>
<div markdown="1">

FL-4.4.1 (K2) 오류 추정을 설명할 수 있다.
- A. 오답- 오류 추정은 사용자들이 테스트 대상과 상호작용에 어떻게 실패하는지 추측하기 위한 사용성 기법이 아니다.
- B. 오답- 한때 개발자였던 테스터가 오류를 추정할 때 도움을 얻기 위해 자신의 경험을 활용할 수 있지만, 이 기법은 개발에 대한 이전 지식에 기반한 것은 아니다.
- C. 정답- 오류 추정의 기본 개념은 테스터가 과거의 경험에 비추어 테스트 대상에 어떤 결함이 있을지, 개발자가 어떤 실수를 했을지 추측하는 것이다.
- D. 오답- 개발 작업을 따라하면 테스터가 개발자와 동등한 기술을 보유해야 하고 개발 수행에 소요되는 시간과 같이 실용적이지 못한 문제들이 있다. 이는 에러 추정이 아니다.

</div>
</details>

---

C - Q19. 다음 중 결정 커버리지를 올바르게 설명한 것은?
- a. 조건 결과(condition outcomes)의 커버리지
- b. 결정 커버리지는 구문(statement) 커버리지와 동의어이다.
- c. 실행 가능한 구문의 커버리지
- d. 결정문 결과(decision outcomes)의 커버리지

<details>
<summary><span style="color:red">Answer</span></summary>
<div markdown="1">

용어, K1
- a. 오답- 조건 커버리지의 용어 정의이다.
- b. 오답- 결정 커버리지는 상위 수준의 커버리지이며 두 용어는 용어사전에서 동의어로 정의되지 않았다.
- c. 오답- 구문 커버리지의 용어 정의이다.
- d. 정답- 결정 값에 적용되는 커버리지의 용어 정의이다.

</div>
</details>

---

C - Q20. 반복주기 계획 단계에 앞서, 조기 QA 및 테스트 원리 적용 방안으로 사용자 스토리와 인수 조건을 학습하고, 사용자 스토리로부터 테스트 컨디션과 테스트 케이스를 도출하고 있다.<br>
이 상황에 적용하고 있는 테스트 기법은?
- a. 화이트 박스 테스팅
- b. 블랙 박스 테스팅
- c. 경험 기반 테스팅
- d. 오류 추정

<details>
<summary><span style="color:red">Answer</span></summary>
<div markdown="1">

FL-4.1.1, K2
- a. 오답- 구조 기반 또는 화이트 박스 기법은 아키텍처, 상세 설계, 내부 구조 또는 테스트 대상의 코드 분석을 기반으로 한다.
- b. 정답- 행위 기반 또는 블랙 박스 기법은 기능 또는 비기능 행위를 설명하는 적절한 테스트 베이시스(예, 공식 요구사항 문서, 명세, 유스 케이스, 사용자 스토리 또는 비즈니스 프로세스) 분석을 기반으로 한다.
- c. 오답- 경험기반 기법은 테스트 항목 결정을 위해 개발자, 테스터 및 사용자의 경험을 지렛대로 삼는다.
- d. 오답- 오류 추정은 경험 기반 테스팅의 한 유형으로 블랙박스 테스팅이 아니다.

</div>
</details>

---

C - Q21. 다음 중 탐색적 테스팅에 대한 설명으로 옳은 것은?
- a. 유사한 애플리케이션과 기술에 대한 테스트 경험이 더 많은 테스터가 경험이 적은 테스터보다 탐색적 테스팅을 더 잘 수행할 가능성이 크다.
- b. 탐색적 테스팅으로는 공식적인 테스트 기법으로 도출한 결과 이상의 추가 테스트를 식별할 수 없다.
- c. 탐색적 테스팅 세션을 완료하는데 필요한 시간은 미리 예측할 수 없다.
- d. 탐색적 테스팅에서 블랙 박스 기법을 사용할 수는 있지만 화이트 박스 기법은 사용할 수 없다.

<details>
<summary><span style="color:red">Answer</span></summary>
<div markdown="1">

FL-4.4.2, K2
- a. 정답- 탐색적 테스팅은 테스터의 기술과 경험을 활용하는 경험 기반 테스팅의 한 형태이다.
- b. 오답- 탐색적 테스팅은 공식 테스팅 기법을 보완하는 데 유용하다.
- c. 오답- 세션 기반 테스트 관리에서 탐색적 테스팅은 정해진 시간 안에 수행되고 테스터는 테스팅을 이끌어가기 위해 테스트 목적이 담긴 테스트 차터를 사용한다.
- d. 오답- 탐색적 테스팅은 이 실러버스에 나오는 다른 블랙박스, 화이트박스, 경험기반 기법의 사용을 포함할 수 있다.

</div>
</details>

---

C - Q22. 당신은 고객이 은행 계좌에 접근해 관리할 수 있는 모바일 앱을 테스트하고 있다. 이러한 앱들의 사용자 관심 극대화, 사용 편의성, 접근성 같은 주제를 다룬 유명한 책에 나온 사용자 인터페이스 모범 사례의 일반적인 목록들과 비교해 각 페이지와 페이지 내의 필드를 평가하는 테스트 스위트를 수행하고 있다.<br>
다음 중 이 테스트 기법에 가장 적합한 것은?
- a. 명세 기반 기법 (Specification-based)
- b. 탐색적 기법 (Exploratory)
- c. 체크리스트 기반 기법 (Checklist-based)
- d. 오류 추정 (Error guessing)

<details>
<summary><span style="color:red">Answer</span></summary>
<div markdown="1">

FL-4.4.3, K2
- a. 오답- 책은 일반적인 지침을 제공하지만 공식적 요구사항 문서나 명세, 유스 케이스 집합, 사용자 스토리나 비즈니스 프로세스는 아니다.
- b. 오답- 이 목록을 테스트 차터 세트로 생각할 수 있지만 테스트 컨디션(conditions) 목록과 더 유사하다.
- c. 정답- <span style="color:red">사용자 인터페이스 모범 사례(best practices) 목록은 테스트 컨디션 목록이다.</span>
- d. 오답- 이 테스트는 일어날 수 있는 장애에 집중하기보다 사용성 측면에서 사용자에게 중요한 것에 대한 지식에 초점을 맞춘다.

</div>
</details>

---

C - Q23. 고객이 은행 계좌에 접근해 관리할 수 있는 모바일 앱이 있다. 고객의 생일이나 다른 일정에 맞춰 개별화된 인사말을 보내기 위해 고객의 SNS 계정과 은행 기록을 확인하는 기능 집합이 방금 전 사용자 스토리에 추가됐다.<br>
다음 중 인사말을 보내야 하는 상황과 보내지 않아야 하는 상황을 확인하는 코드의 단위 테스트 진행 시 개발자가 사용할 수 있는 테스트 기법은?
- a. 구문 테스팅 (Statement testing)
- b. 탐색적 테스팅 (Exploratory testing)
- c. 상태 전이 테스팅 (State transition testing)
- d. 결정 테스팅 (Decision testing)

<details>
<summary><span style="color:red">Answer</span></summary>
<div markdown="1">

FL-4.3.2, K2
- a. 오답- 구문 테스팅은 코드에서 실행 가능한 구문을 수행하므로 테스트되지 않는 특정 인사말이 없을 수 있다.
- b. 오답- 테스트 차터에 각 인사말 유형의 존재 여부에 대한 테스트를 구체적으로 언급하지 않는 한, 탐색적 테스트의 커버리지 측정은 어려울 수 있다.
- c. 오답- 상태 전이 테스팅은 테스트 대상이 현재 조건이나 이전 이력에 따른 입력값에 다르게 반응하는 경우에 유용하지만, 이 경우 테스트 대상은 현재 날짜가 특정 마일스톤과 일치하는지 여부와 관련 인사말을 보여줄지를 결정해야 한다.
- d. 정답- 결정 테스팅은 결정 지점에서 발생하는 제어 흐름을 따르는 테스트 케이스를 포함한다. 이 경우 인사말을 보내야 하는지 여부를 결정한다.

</div>
</details>

---

C - Q24. 2년 넘게 수정한 적이 없는 배치(batch) 애플리케이션이 있다. 이 애플리케이션은 한 달에 한 번 야간에 고객 발송용 이메일에 들어갈 문구를 생성한다. 이 애플리케이션은 모든 고객의 계정을 검토하고 계정의 지난 달 거래를 모두 나열한다. 이를 위해 고객 확인(바깥쪽 루프), 각 고객의 계정 확인(가운데 루프), 각 계정의 거래 내용을 확인(안쪽 루프)하는 중첩 루프(nested loop) 구조를 사용한다.<br>
어느 날 밤, 지난 달 거래가 없었던 일부 고객들에게 이메일 문구 발송에 문제가 생겨 배치 애플리케이션이 일찍 종료됐다. 이는 이 애플리케이션 사용 이래로 한번도 발생한 적이 없는 아주 이례적인 일이었다.<br>
결함을 수정하는 동안 개발자가 이러한 결함을 효과적으로 테스트하는 기법을 추천해달라고 한다.<br>
다음 중 내재된 결함을 찾는 데 가장 적합한 테스트 기법은?
- a. 결정 테스팅 (Decision testing)
- b. 구문 테스팅 (Statement testing)
- c. 체크리스트 기반 테스팅 (Checklist-based testing)
- d. 오류 추정 (Error guessing)

<details>
<summary><span style="color:red">Answer</span></summary>
<div markdown="1">

FL-4.3.3, K2
- a. 정답- 루프 구조에 대해 구문 커버리지는 루프 안의 모든 구문이 실행되는 것을 요구하지만 결정 커버리지는 루프가 실행되는 조건과 건너뛰는 조건을 모두 테스트해야 한다.
- b. 오답- 루프 구조에 대해 구문 커버리지는 루프 안의 모든 구문이 실행되는 것을 요구하지만 결정 커버리지는 루프가 실행되는 조건과 건너뛰는 조건을 모두 테스트해야 한다.
- c. 오답- 체크리스트는 경험, 결함, 장애 데이터, 사용자에게 중요한 것에 대한 지식, 소프트웨어가 어떻게 왜 실패하는지에 대한 이해를 바탕으로 하며 그 중 어느 것도 그러한 테스트 컨디션을 포함하지 않을 수 있다.
- d. 오답- 개발자가 모든 계정에 대해 한달에 적어도 한 번 이상의 거래가 있을 것이라는 잘못된 가정을 하는 사람이 있을 수 있지만, 결정 테스트만 해당 조건의 테스트를 보장한다.

</div>
</details>

---

C - Q25. 신용카드 결제만 가능한 무인 주유기를 테스트하고 있다. 신용 카드가 인식되면, 연료 주입기 입구가 탱크로 들어가고, 원하는 등급이 선택되며, 고객이 키패드를 사용하여 원하는 양을 입력한다. 키패드로는 숫자만 입력할 수 있다.<br>
사용자는 0.1 갤론부터 50 갤론까지 선택할 수 있다.<br>
다음 중 이 입력값에 대한 동등분할 영역을 커버하는 최소한의 데이터 묶음은?
- a. 0.0, 20.0, 60.0
- b. 0.0, 0.1, 50.0
- c. 0.0, 0.1, 50.0, 70.0
- d. 0.1, 0.0, 0.1, 49.9, 50.0, 50.1

<details>
<summary><span style="color:red">Answer</span></summary>
<div markdown="1">

FL-4.2.1, K3<br>
3개의 동등 파티션으로 구분할 수 있다:
- 완료된 거래 없음 (0.0 갤론)
- 유효 거래 (0.1 - 50갤론)
- 유효하지 않은 양 선택 (50.1갤론 이상)

따라서, 다음과 같이 설명할 수 있다.
- a. 정답- 이 입력값들은 위의 동등 파티션을 하나씩 커버한다.
- b. 오답- 이 입력값들은 유효하지 않은 양을 선택하는 파티션을 커버하지 않는다.
- c. 오답- 이 입력값들은 유효한 거래에 해당하는 동등 파티션에서 두 개의 값을 커버하므로 최소한의 묶음이 될 수 없다.
- d. 오답- 이 입력값들은 2개의 경계에 대한 3-포인트 경계값을 커버한다. 동등 파티션을 커버하기 위한 최소한의 입력값들은 아니다.

</div>
</details>

---

C - Q26. 당신은 향신료, 밀가루 및 기타 품목을 대량으로 판매하는 전자 상거래 시스템을 테스트하고 있다. 품목 판매 단위는 그램(향료 및 기타 고가 품목의 경우) 또는 킬로그램(밀가루 및 기타 저가 품목의 경우) 중 하나이다. 단위에 상관없이 최소 유효 단위는 0.5 단위(예, 강황 0.5g), 최대 유효 단위는 25 단위(예, 설탕 25kg)이다. 단위의 정밀도는 0.1이다.<br>
다음 중 이 입력값에 대한 2-포인트 경계값을 커버하는 입력값의 묶음은?
- a. 0.3, 10.0, 28.0
- b. 0.4, 0.5, 0.6, 24.9, 25.0, 25.1
- c. 0.4, 0.5, 25.0, 25.1
- d. 0.5, 0.6, 24.9, 25.0

<details>
<summary><span style="color:red">Answer</span></summary>
<div markdown="1">

FL-4.2.2, K3<br>
다음과 같은 경계값을 갖는 세 개의 동등 파티션으로 구분할 수 있다:
- 비유효/너무 낮음 (0.4 이하)
- 유효 (0.5 ~ 25)
- 비유효/너무 높음 (25.1이상)

따라서, 다음과 같이 설명할 수 있다:
- a. 오답- 4개의 경계값 중 어떤 값도 이 테스트 세트에 포함되지 않는다. 이 테스트들은 동등 파티션을 커버한다.
- b. 오답- 4개의 값 모두 테스트 세트에 포함되지만 두 개의 값이 추가되어 있고 이는 3-포인트 경계값 분석과 관련된다.
- c. 정답- 4가지 2-포인트 경계값 각각이 이 테스트 세트에 포함된다.
- d. 오답- 4개의 값 모두 유효 파티션에만 포함된다.

</div>
</details>

---

C - Q27. 다음은 온라인 항공예약시스템에서 항공 사용이 빈번한 고객을 대상으로 포인트로 항공권을 결제할 수 있도록 하는 기능에 대한 결정 테이블이다:

<img src="/img/istqbCtfl/QnA_C27.png"/>

유효한 계정/비밀번호가 아닌 경우는 두 가지 동등분할 영역이 있다. 하나는 계정이 유효하지 않은 경우이고, 다른 하나는 비밀번호가 유효하지 않은 경우이다. 계정/비밀번호가 유효한 경우는 계정과 비밀번호 모두가 유효한 경우이므로 동등분할 영역은 하나만 존재한다.<br>
유효 계정/비밀번호에 대한 동등분할 영역을 커버하면서 결정 테이블 경우의 수도 만족하기 위한 테스트를 설계한다고 할 때, 최소 몇 개의 테스트가 필요한가?
- a. 2
- b. 3
- c. 4
- d. 9

<details>
<summary><span style="color:red">Answer</span></summary>
<div markdown="1">

FL-4.2.3, K3<br>
결정 테이블의 각 열에 대해 적어도 하나의 테스트가 있다. 그러나 1열은 두 개의 테스트가 필요하다. 하나는 유효하지 않은 계정에 대한 것이고, 다른 하나는 계정은 유효하지만 암호가 유효하지 않은 경우로 최소 테스트 개수는 4개이다.<br>
따라서, c.가 정답이다.

</div>
</details>

---

C - Q28. 다음은 신용카드 결제만 가능한 무인 주유기의 상태 전이 다이어그램이다:

<img src="/img/istqbCtfl/QnA_C28.png"/>

위 상태 전이 다이어그램에서 각 전이를 커버하는 최소한의 테스트를 개발한다고 하자.<br>
각 테스트가 시작 상태인 ‘고객 대기’에서 시작하여 다시 시작 상태로 돌아오면 끝난다고 가정할 때, 몇 개의 테스트가 필요한가?
- a. 4
- b. 7
- c. 1
- d. 무한정(infinite)

<details>
<summary><span style="color:red">Answer</span></summary>
<div markdown="1">

FL-4.2.4, K3<br>
이 질문에 따르면 각 전이가 최소 한 번 수행돼야 한다. 그렇게 하기 위해 첫 번째 테스트는 성공적으로 주유하는 긍정 경로를, 그 다음은 [주유 준비]에서 취소 또는 타임아웃, 다음 테스트로 [연료 유형 선택 대기]에서 취소 또는 타임아웃, 마지막으로 유효하지 않은 신용카드를 삽입하는 경우를 테스트해야 한다. 4회 미만의 테스트는 고객의 이벤트를 기다리는 상태 중 하나를 커버하지 못하거나 테스트 시작 또는 종료에 대한 규칙을 위반하게 된다. 네 가지가 넘는 테스트에는 이미 커버된 전이를 다시 수행하는 테스트를 포함한다.<br>
따라서, a.가 정답이다.

</div>
</details>

---

C - Q29. 당신은 향신료, 밀가루 및 기타 품목을 대량으로 판매하는 전자 상거래 시스템을 테스트하고 있다. 품목 판매 단위는 그램(향료 및 기타 고가 품목의 경우) 또는 킬로그램(밀가루 및 기타 저가 품목의 경우) 중 하나이다. 단위에 상관없이 최소 유효 단위는 0.5 단위(예, 강황 0.5g), 최대 유효 단위는 25 단위(예, 설탕 25kg)이다. 단위의 정밀도는 0.1이다.<br>
다음 중 이 입력값의 동등분할을 커버하는 최소한의 입력값의 묶음은?
- a. 10.0, 28.0
- b. 0.4, 0.5, 25.0, 25.1
- c. 0.2, 0.9, 29.5
- d. 12.3

<details>
<summary><span style="color:red">Answer</span></summary>
<div markdown="1">

FL-4.2.1, K3<br>
다음과 같은 경계값을 갖는 동등 파티션 세 개로 구분할 수 있다:
- 비유효/너무 낮음 (0.4 이하)
- 유효 (0.5 – 25.0)
- 비유효/너무 높음 (25.1 이상)

따라서, 다음과 같이 설명할 수 있다:
- a. 오답- 이 테스트 세트는 동등 파티션 중 2개 파티션만 커버한다.
- b. 오답- 이 테스트 세트에는 4개의 경계값 각각이 포함돼 있지만 문제에서는 최소한의 동등 분할 커버리지를 요구하고 있으므로 0.5와 25.0은 제외해야 한다.
- c. 정답- 이 테스트 세트는 3개의 동등 파티션을 각각 커버한다.
- d. 오답- 이 테스트 세트는 동등 파티션 중 하나만 커버한다.

</div>
</details>

# ● 자료참고
{: .notice--info .text-center}

[실러버스 본문](http://www.kstqb.org/board_skin/board_view.asp?idx=426&page=1&bbs_code=4&key=0&word=&etc=ISTQB){: .btn .btn--info}
[실러버스 용어](http://www.kstqb.org/board_skin/board_view.asp?idx=342&page=2&bbs_code=4&key=0&word=&etc=ISTQB){: .btn .btn--info}
[샘플문제](http://www.kstqb.org/board_skin/board_view.asp?idx=433&page=2&bbs_code=5&key=0&word=&etc=){: .btn .btn--info}